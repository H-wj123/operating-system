FAT(File Allocation Table)은 각 블록 번호(항목 번호)에 대해 다음 블록의 위치 또는 파일 끝을 나타냅니다. 각 번호는 연결 리스트처럼 다음 블록의 위치를 가리킵니다.
따라서 53번에서 시작하는 파일은 다음 순서의 블록들을 차례로 사용합니다
53 → 2 → 124 → 54 → 320 (끝)
총 5개 블록입니다.
문제 1
(1) exam.txt가 53번 블록부터 시작한다고 할 때, 연결된 블록들을 순서대로 나열하라.
풀이: 위에서 분석한 대로, FAT에서 53번부터 추적하면:
53 → 2 → 124 → 54 → 320 
정답:
53, 2, 124, 54, 320
(2) 블록 크기가 1KB라면, exam.txt 파일의 크기로 가장 적절한 것은?
풀이: 연결된 블록 수: 5개, 블록당 크기: 1KB
총 크기: 5KB
보기 중 가장 적절한 값:
보기엔 ①1KB, ②4KB, ③4.5KB, ④53KB
따라서 답은 3번이다
문제 2
(2) score.txt가 55번 블록부터 시작할 때, 연결된 블록들을 순서대로 나열하라.
풀이: FAT를 보면, 55 → 321 → 52 → 123 → -1
따라서 연결된 블록은:
55, 321, 52, 123
→ 총 4개 블록
(2) 블록 크기가 2KB일 때, score.txt의 크기로 가장 적절한 것은?

풀이: 4개 블록 × 2KB = 8KB
정답: 가장 적절한 건 ② 7KB (일반적으로 정확한 크기를 모르면, 초과하지 않는 가장 근접값 선택)
문제 3 (UNIX i-node 관련)
(1) /usr/dev/source/app.c를 읽기 위해 운영체제는 몇 개의 i-node를 읽어야 하는가?
풀이:
UNIX 파일 시스템에서 경로를 따라갈 때, 각 디렉토리는 자체 i-node가 있음.
따라서 경로: /usr → /usr/dev → /usr/dev/source → /usr/dev/source/app.c
→ i-node를 읽는 개수: 4개
정답: 4개
(2) i-node와 디스크 블록들이 읽히는 순서를 기술하라.
순서:

루트 i-node
루트 디렉터리 블록들
/usr의 i-node
/usr 디렉터리 블록
/usr/dev의 i-node
/usr/dev 디렉터리 블록
/usr/dev/source의 i-node
/usr/dev/source 디렉터리 블록
/usr/dev/source/app.c의 i-node
/usr/dev/source/app.c의 파일 블록

(3) 운영체제가 i-node 테이블을 메모리에 적재해 사용하는 이유는?
 
설명: 디스크 접근은 느림 → 자주 접근되는 i-node 정보를 메모리에 캐싱
	경로 탐색 시 반복적으로 i-node를 읽어야 함
	성능 향상을 위해 메모리에 i-node 정보를 유지 (캐시처럼 사용)
요약:
운영체제는 파일 접근의 성능을 높이기 위해 자주 사용되는 i-node 정보를 메모리에 저장하여 디스크 접근을 줄입니다.
